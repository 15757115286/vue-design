## 创建编译器

#### compileToFunctions

接下来我们的主要工作，就是搞清楚 `compileToFunctions` 函数，根据 `platforms/web/entry-runtime-with-compiler.js` 文件头部的 `import` 引用关系可知，`compileToFunctions` 函数来自于当前目录下的 `./compiler/index.js` 文件，打开 `./compiler/index.js` 文件，可以发现这样一句代码：

```js
const { compile, compileToFunctions } = createCompiler(baseOptions)
```

上面的代码中 `compileToFunctions` 函数是从 `createCompiler` 函数的返回值中解构出来的。

由此可知 `compileToFunctions` 函数是通过以 `baseOptions` 为参数调用 `createCompiler` 函数创建出来的。`createCompiler` 函数顾名思义他的作用就是创建一个编译器，那么到底是怎么创建出来的呢？想搞清楚这个问题我们就需要具体看一下 `createCompiler` 函数了，根据引用关系可知 `createCompiler` 函数来自于 `compiler/index.js` 文件，注意这里的 `compiler/index.js` 可不是 `./compiler/index.js`，这里的 `compiler/index.js` 指的是 `src/compiler/index.js` 文件，我们打开这个文件看一下：

```js
/* @flow */

import { parse } from './parser/index'
import { optimize } from './optimizer'
import { generate } from './codegen/index'
import { createCompilerCreator } from './create-compiler'

// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
export const createCompiler = createCompilerCreator(function baseCompile (
  template: string,
  options: CompilerOptions
): CompiledResult {
  const ast = parse(template.trim(), options)
  optimize(ast, options)
  const code = generate(ast, options)
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
})
```

以上是 `src/compiler/index.js` 文件的全部代码，可知这个文件唯一的作用就是导出一个函数，即 `createCompiler` 函数，该函数就是用来创建编译器的，或者我们可以称该函数为 `编译器的创建者`。那么 `createCompiler` 函数的内容是什么呢？仔细查看代码，我们发现 `createCompiler` 函数也是通过一个函数创建出来的，这个函数就是 `createCompilerCreator`，并且传递了 `baseCompile` 函数作为参数。也就说 `createCompiler` 函数的内容是 `createCompilerCreator` 函数的返回值，其实这么看的话我们倒是可以把 `createCompilerCreator` 函数称作 `'编译器创建者' 的创建者`，我们整理一下思路如下图：

![](http://ovjvjtt4l.bkt.clouddn.com/2017-11-09-073724.jpg)

接下来我们需要看一看 `'编译器创建者' 的 创建者` 是怎么创建出编译器创建者的，也就是 `createCompilerCreator` 函数的内容，该函数来自于 `create-compiler.js` 文件，打开该文件找到 `createCompilerCreator` 函数如下：

```js
/* @flow */

import { extend } from 'shared/util'
import { detectErrors } from './error-detector'
import { createCompileToFunctionFn } from './to-function'

export function createCompilerCreator (baseCompile: Function): Function {
  return function createCompiler (baseOptions: CompilerOptions) {
    // ...
  }
}
```

以上代码是 `create-compiler.js` 文件的全部内容，只不过做了简化，去掉了 `createCompiler` 函数的函数体。我们可以发现 `createCompilerCreator` 函数直接返回了 `createCompiler` 函数，而这个函数就是我们所说的 `编译器的创建者`。那么传递给 `createCompilerCreator` 函数的参数 `baseCompile` 在哪里调用的呢？肯定是在 `createCompiler` 函数体内调用的。

现在我们再回到 `src/compiler/index.js` 文件，再次查看如下代码：

```js
// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
export const createCompiler = createCompilerCreator(function baseCompile (
  template: string,
  options: CompilerOptions
): CompiledResult {
  const ast = parse(template.trim(), options)
  optimize(ast, options)
  const code = generate(ast, options)
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
})
```

我们已经知道一件事，那就是这里的 `createCompiler` 就是 `createCompilerCreator` 函数的返回值，也就是 `src/compiler/create-compiler.js` 文件内的 `createCompiler` 函数：

```js
export function createCompilerCreator (baseCompile: Function): Function {
  // 也就是这个 createCompiler 函数
  return function createCompiler (baseOptions: CompilerOptions) {
    // ...
  }
}
```

那么现在再看 `platforms/web/compiler/index.js` 文件下的这句代码：

```js
const { compile, compileToFunctions } = createCompiler(baseOptions)
```

其实这里调用的 `createCompiler` 也就是 `src/compiler/create-compiler.js` 文件的 `createCompiler` 函数。我们查看一下  `src/compiler/create-compiler.js` 文件的 `createCompiler` 函数如下：

```js
export function createCompilerCreator (baseCompile: Function): Function {
  return function createCompiler (baseOptions: CompilerOptions) {
    function compile (
      template: string,
      options?: CompilerOptions
    ): CompiledResult {
      // ...
    }

    return {
      compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    }
  }
}
```

可以发现 `createCompiler` 函数的返回值就是一个包含 `compileToFunctions` 属性的对象：

```js
return {
  compile,
  compileToFunctions: createCompileToFunctionFn(compile)
}
```

而这里的 `compileToFunctions` 属性就是 `platforms/web/compiler/index.js` 文件中解构出来的 `compileToFunctions`：

```js
// 这里通过 createCompiler 函数的返回值结构出 compileToFunctions
const { compile, compileToFunctions } = createCompiler(baseOptions)
```

所以上面代码中执行的 `createCompiler` 函数实际上就是 `compiler/create-compiler.js` 文件中的 `createCompiler` 函数，该函数的返回值包含了真正的编译器 `compileToFunctions`，接下来我们就看看 `createCompiler` 都做了什么，打开 `compiler/create-compiler.js` 文件找到 `createCompiler` 函数如下：

```js
export function createCompilerCreator (baseCompile: Function): Function {
  // createCompiler 函数作为 createCompilerCreator 函数的返回值
  return function createCompiler (baseOptions: CompilerOptions) {
    // 定义 compile 函数
    function compile (
      template: string,
      options?: CompilerOptions
    ): CompiledResult {
      // ...
    }

    // 返回 compile 和 compileToFunctions
    return {
      compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    }
  }
}
```

从上面的代码可以看到 `createCompiler` 函数的内容其实很简单，就是定义了 `compile` 函数，然后返回一个对象，这个对象包含了 `compile` 函数本身，同时包含了 `compileToFunctions` 函数。这就是 `createCompiler` 所做的内容，但是这就完了吗？还没有，因为我们发现 `compileToFunctions` 这个函数是通过以 `compile` 函数作为参数调用 `createCompileToFunctionFn` 函数生成的，所以我们一直所说的 `compileToFunctions` 函数其实准确的讲它应该是 `createCompileToFunctionFn` 函数的返回值，那么我们看看 `createCompileToFunctionFn` 函数都干了什么，根据引用关系可知 `createCompileToFunctionFn` 函数在 `src/compiler/to-function.js` 文件中，打开这个文件找到该函数：

```js
export function createCompileToFunctionFn (compile: Function): Function {
  const cache: {
    [key: string]: CompiledFunctionResult;
  } = Object.create(null)

  return function compileToFunctions (
    template: string,
    options?: CompilerOptions,
    vm?: Component
  ): CompiledFunctionResult {
    ...
  }
}
```

以上是 `createCompileToFunctionFn` 函数的代码，我们发现这个函数的返回值是一个函数，该函数才是我们真正想要的 `compileToFunctions`，在返回这个函数之前定义了常量 `cache`，所以 `cache` 变量肯定是被 `compileToFunctions` 函数引用的，那么这里可以理解为创建了一个闭包，其实如果大家留意的话，在上面的讲解中我们已经遇到了很多利用闭包引用变量的场景，还是拿上面的代码为例，`createCompileToFunctionFn` 函数接受一个参数 `compile`，而这个参数其实也是被 `compileToFunctions` 闭包引用的。

至此我们经历了一波三折，终于找到了 `compileToFunctions` 函数，`/entry-runtime-with-compiler.js` 文件中执行的 `compileToFunctions` 函数，其实就是在执行 `src/compiler/to-function.js` 文件中 `createCompileToFunctionFn` 函数返回的 `compileToFunctions` 函数。

#### 

经过前面的讲解，我们已经知道了 `entry-runtime-with-compiler.js` 文件中调用的 `compileToFunctions` 的真正来源，可以说为了创建 `compileToFunctions` 函数经历了一波三折，现在大家也许会有疑问，比如为了要弄的这么复杂？我们暂时把这个疑问放在心里，随着我们的深入，大家将会慢慢理解其内涵。

这个小节我们就以 `entry-runtime-with-compiler.js` 文件中调用的 `compileToFunctions` 开始，仔细探索其所做的事情，打开 `entry-runtime-with-compiler.js` 文件找到这段代码：

```js
const { render, staticRenderFns } = compileToFunctions(template, {
  shouldDecodeNewlines,
  shouldDecodeNewlinesForHref,
  delimiters: options.delimiters,
  comments: options.comments
}, this)
```

上面这段代码存在于 `Vue.prototype.$mount` 函数体内，我们已经知道 `compileToFunctions` 函数的作用是把传入的模板字符串编(`template`)译成渲染函数(`render`)的。所以传递给 `compileToFunctions` 的第一个参数就是模板字符串(`template`)，而第二个参数则是一些选项(`options`)，接下来我们先把这里传递的选项对象搞清楚，选项对象如下：

```js
{
  shouldDecodeNewlines,
  shouldDecodeNewlinesForHref,
  delimiters: options.delimiters,
  comments: options.comments
}
```













